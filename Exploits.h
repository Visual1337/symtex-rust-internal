
// public static bool Trace(Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = ∞, int layerMask = -5, QueryTriggerInteraction triggerInteraction = 0, BaseEntity ignoreEntity) { }
Projectile* PrUpdate;
DWORD64 PlayerProjectileAttack_Orig;
// public struct Bounds : IEquatable<Bounds>, IFormattable // TypeDefIndex: 10200
auto LookRotation = reinterpret_cast<Vector4(*)(Vector3, Vector3 )>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("Quaternion"), _("LookRotation"), 2, _(""), _("UnityEngine"))));
auto set_rotation = reinterpret_cast<void(*)(Transform*, Vector4 )>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("Transform"), _("set_rotation"), 1, _(""), _("UnityEngine"))));

class Bounds {
public:
	Vector3 m_center;
	Vector3 m_extents;
	Vector3 center;
	Vector3 extents;
	Vector3 max;
	Vector3 min;
	Vector3 size;
};
// ProjectileLaunch
//auto GetBounds = reinterpret_cast<Bounds(*)(BasePlayer*)>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("Bounds"), _("set_rotation"), 1, _(""), _("UnityEngine"))));
auto get_extents = reinterpret_cast<Vector3(*)(Bounds)>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("Bounds"), _("get_extents"), 1, _(""), _("UnityEngine"))));
auto GetBounds = reinterpret_cast<Bounds(*)(BasePlayer*)>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("BasePlayer"), _("GetBounds"), 1, _(""), _(""))));
auto Trace = reinterpret_cast<bool(*)(Ray, float, RaycastHit*, float, int, QueryTriggerInteraction, BasePlayer*)>(0);
auto Update = reinterpret_cast<void(*)(Projectile*)>(0);
auto DoMovement = reinterpret_cast<bool(*)(Projectile*, float)>(0);
auto ProjectileLaunch = reinterpret_cast<void (*)(Projectile*)>(0);
auto DoVelocityUpdate = reinterpret_cast<void(*)(Projectile*, float)>(0);
auto get_isAlive = reinterpret_cast<bool (*)(Projectile*)>(0);
auto UpdateVelocity = reinterpret_cast<void (*)(Projectile*, float)>(0);
auto get_time = reinterpret_cast<float(*)()>(0);
auto FindBone = reinterpret_cast<Transform * (*)(BasePlayer*, Str)>(0);
//auto InverseTransformPoint = reinterpret_cast<Vector3(*)(Transform*, Vector3)>(0);
auto DoHit = reinterpret_cast<bool(*)(Projectile*, HitTest*, Vector3, Vector3)>(0);
auto BuildAttackMessage = reinterpret_cast<DWORD64(*)(HitTest*)>(0);
auto HitNormalWorld = reinterpret_cast<Vector3(*)(HitTest*)>(0);
auto HitPointWorld = reinterpret_cast<Vector3(*)(HitTest*)>(0);
auto Retire = reinterpret_cast<void(*)(Projectile*)>(0);
auto get_gameObject = reinterpret_cast<DWORD64(*)(Transform*)>(0);
auto Trace_All = reinterpret_cast<void(*)(HitTest*, DWORD64, int)>(0);
auto get_isAuthoritative = reinterpret_cast<bool(*)(Projectile*)>(0);
auto InverseTransformPoint = reinterpret_cast<Vector3(*)(Transform*, Vector3)>(0);
auto InverseTransformDirection = reinterpret_cast<Vector3(*)(Transform*, Vector3)>(0);
auto ServerProjectileHit = reinterpret_cast<void (*)(ItemModProj*, HitInfo*)>(0);
auto OnAttacked_Entity = reinterpret_cast<void (*)(DWORD64, HitInfo*)>(0);
void InitExploits()
{
	OnAttacked_Entity = reinterpret_cast<void (*)(DWORD64, HitInfo*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("BasePlayer"), _("OnAttacked"), 1, _(""), _(""))));
	ServerProjectileHit = reinterpret_cast<void (*)(ItemModProj*, HitInfo*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("ItemModProjectile"), _("ServerProjectileHit"), 1, _(""), _(""))));
	ProjectileLaunch = reinterpret_cast<void (*)(Projectile*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("Launch"), 0, _(""), _(""))));
	get_extents = reinterpret_cast<Vector3(*)(Bounds)>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("Bounds"), _("get_extents"), 0, _(""), _("UnityEngine"))));
	GetBounds = reinterpret_cast<Bounds(*)(BasePlayer*)>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("BasePlayer"), _("GetBounds"), 1, _(""), _(""))));
	LookRotation = reinterpret_cast<Vector4(*)(Vector3, Vector3)>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("Quaternion"), _("LookRotation"), 2, _(""), _("UnityEngine"))));
	set_rotation = reinterpret_cast<void(*)(Transform*, Vector4)>(*reinterpret_cast<uintptr_t*>(Il2cpp::Method(_("Transform"), _("set_rotation"), 1, _(""), _("UnityEngine"))));
	DoMovement = reinterpret_cast<bool(*)(Projectile*, float)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("DoMovement"), 0, _(""), _(""))));
	DoVelocityUpdate = reinterpret_cast<void(*)(Projectile*, float)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("DoVelocityUpdate"), 0, _(""), _(""))));
	//Trace = reinterpret_cast<bool(*)(Ray, float, RaycastHit*, float, int, QueryTriggerInteraction, BasePlayer*)>(Il2cpp::Method(_("GamePhysics"), _("Trace"), 7, _(""), _("")));
	Trace = reinterpret_cast<bool(*)(Ray, float, RaycastHit*, float, int, QueryTriggerInteraction, BasePlayer*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("GamePhysics"), _("Trace"), 7, _(""), _(""))));
	get_isAuthoritative = reinterpret_cast<bool(*)(Projectile*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("get_isAuthoritative"), 0, _(""), _(""))));
	InverseTransformPoint = reinterpret_cast<Vector3(*)(Transform*, Vector3)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Transform"), _("InverseTransformPoint"), 1, _(""), _("UnityEngine"))));
	InverseTransformDirection = reinterpret_cast<Vector3(*)(Transform*, Vector3)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Transform"), _("InverseTransformDirection"), 1, _(""), _("UnityEngine"))));
	Trace_All = reinterpret_cast<void(*)(HitTest*, DWORD64, int)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("GameTrace"), _("TraceAll"), 3, _(""), _(""))));
	get_gameObject = reinterpret_cast<DWORD64(*)(Transform*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Component"), _("get_gameObject"), 0, _(""), _("UnityEngine"))));
	Retire = reinterpret_cast<void(*)(Projectile*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("Retire"), 0, _(""), _(""))));
	HitPointWorld = reinterpret_cast<Vector3(*)(HitTest*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("HitTest"), _("HitPointWorld"), 0, _(""), _(""))));
	HitNormalWorld = reinterpret_cast<Vector3(*)(HitTest*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("HitTest"), _("HitNormalWorld"), 0, _(""), _(""))));
	DoHit = reinterpret_cast<bool(*)(Projectile*, HitTest*, Vector3, Vector3)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("DoHit"), 3, _(""), _(""))));
	FindBone = reinterpret_cast<Transform* (*)(BasePlayer*, Str)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("BaseEntity"), _("FindBone"), 1, _(""), _(""))));
	get_time = reinterpret_cast<float(*)()>(Il2cpp::resolve_icall(_("UnityEngine.Time::get_time()")));  //(Il2cpp::Method(_("Time"), _("get_time"), 0, _(""), _("UnityEngine"))));
	UpdateVelocity = reinterpret_cast<void (*)(Projectile*, float)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("UpdateVelocity"), -1, _(""), _(""))));
	get_isAlive = reinterpret_cast<bool (*)(Projectile*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("get_isAlive"), 0, _(""), _(""))));
	Update = reinterpret_cast<void(*)(Projectile*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("Projectile"), _("Update"), 0, _(""), _(""))));
	BuildAttackMessage = reinterpret_cast<DWORD64(*)(HitTest*)>(*reinterpret_cast<DWORD64*>(Il2cpp::Method(_("HitTest"), _("BuildAttackMessage"), 0, _(""), _(""))));
}

struct TraceInfo {

	bool valid; // 0x10
	float distance; // 0x14
	BasePlayer* entity; // 0x18   //BasePlayer
	Vector3 point; // 0x20
	Vector3 normal; // 0x2C
	Transform*/*Transform*/ bone; // 0x38
	DWORD64 material; // 0x40
	unsigned int partID; // 0x48
	Transform* collider; // 0x50
};

void AttackMelee(BasePlayer* target, Vector3 pos, Weapon* baseprojectile, Vector3 start_pos = LocalPlayer->GetEyes()->EyePosition(), bool is_player = false) {

	if (!target)
		return;

	Vector3 local_position = start_pos;

	if (baseprojectile->NextAttackTime() >= Unity::get_time())
		return;

	if (baseprojectile->timeSinceDeploy() < baseprojectile->DeployDelay())
		return;

	auto hit_test_class = Il2cpp::InitClass(_("HitTest"));
	if (!hit_test_class)
		return;

	HitTest* hit_test = (HitTest*)Il2cpp::object_new(hit_test_class);

	Ray ray = Ray(local_position, (pos - local_position).Normalized());

	Transform* trans = is_player ? target->GetTransform(47) : Classes::get_transform(target); //: Classes::get_transform(target.Cur);

	if (!trans)
		return;

	hit_test->HitTransform(trans);
	hit_test->AttackRay(ray);
	hit_test->DidHit(true);
	hit_test->HitEntity(target);
	hit_test->HitPoint(InverseTransformPoint(trans, pos));
	hit_test->HitNormal(Vector3(0, 0, 0));
	hit_test->DamageProperties(baseprojectile->DamageProperties());

	Classes::StartAttackCooldown(baseprojectile, baseprojectile->RepeatDelay());

	return Classes::ProcessAttack(baseprojectile, hit_test);
}
float hammerdely = 0;
void HammerSpam(BasePlayer* target, Vector3 pos, Weapon* baseprojectile, Vector3 start_pos = LocalPlayer->GetEyes()->EyePosition(), bool is_player = false) {

	if (!target)
		return;

	if (Classes::HasAttackCooldown(baseprojectile)) return;

	Vector3 local_position = start_pos;

	auto hit_test_class = Il2cpp::InitClass(_("HitTest"));
	if (!hit_test_class)
		return;

	HitTest* hit_test = (HitTest*)Il2cpp::object_new(hit_test_class);

	Ray ray = Ray(local_position, (pos - local_position).Normalized());

	Transform* trans = target->GetTransform(47); //: Classes::get_transform(target.Cur);

	if (!trans)
		return;

	hit_test->HitTransform(trans);
	hit_test->AttackRay(ray);
	hit_test->DidHit(true);
	hit_test->HitEntity(target);
	hit_test->HitPoint(InverseTransformPoint(trans, pos));
	hit_test->HitNormal(InverseTransformDirection(trans, pos));
	hit_test->DamageProperties(baseprojectile->DamageProperties());
	hit_test->HitTest_HitMaterial((Str*)Il2cpp::new_string(_("glass")));

	Classes::StartAttackCooldown(baseprojectile, 0.01);

	return Classes::ProcessAttack(baseprojectile, hit_test);
}

bool ValidateProcessAttack(uintptr_t* target, Vector3 hitPosition, Weapon* baseprojectile, Vector3 start_pos = LocalPlayer->GetEyes()->EyePosition(), bool is_player = false) {
	bool ValidAttack = false;
	BasePlayer* basePlayer = (BasePlayer*)target;
	bool flag = basePlayer->IsValid();
	bool flag6 = target != 0;
	bool flag7 = flag6 && Classes::get_IsNpc((DWORD64)basePlayer->GetPlayerModel());
	int layerMask = (int)Layers::MeleeLineOfSightCheck;
	if (flag6) {
		ValidAttack = Maths::Calc3D_Dist(start_pos, Target.Pos) <= 3 && Maths::Calc3D_Dist(LocalPlayer->GetEyes()->EyePosition(), Target.Pos) < 4;
	}
	if (ValidAttack && flag6)
	{
		Vector3 pointStart = start_pos;
		Vector3 hitPositionWorld = hitPosition;
		Vector3 center = LocalPlayer->GetEyes()->GetCenter();
		Vector3 position = pointStart;
		Vector3 vector = pointStart;
		Vector3 vector2 = hitPositionWorld + ((hitPositionWorld - pointStart) * 0.001f);
		Vector3 vector3 = hitPositionWorld;
		bool flag9 = Unity::LineOfSight(center, position, layerMask, 0.f, 0.f, NULL) && Unity::LineOfSight(position, vector, layerMask, 0.f, 0.f, NULL) && Unity::LineOfSight(vector, vector2, layerMask, 0.f, 0.f, NULL) && Unity::LineOfSight(vector2, vector3, layerMask, 0.f, 0.f, *target);
		ValidAttack = flag9;
	}
	if (ValidAttack && flag && !flag7)
	{
		Vector3 hitPositionWorld2 = hitPosition;
		Vector3 position2 = basePlayer->GetEyes()->EyePosition();
		Vector3 vector4 = basePlayer->GetBoneByID(spine4).midPoint(basePlayer->GetEyes()->EyePosition().midPoint(basePlayer->GetPlayerModel()->ModelPosition()));
		float melee_losforgiveness = 0.2f;
		bool flag10 = Unity::LineOfSight(hitPositionWorld2, position2, layerMask, 0.f, melee_losforgiveness, NULL) && Unity::LineOfSight(position2, hitPositionWorld2, layerMask, melee_losforgiveness, 0.f, NULL);
		if (!flag10)
		{
			flag10 = Unity::LineOfSight(hitPositionWorld2, vector4, layerMask, 0.f, melee_losforgiveness, NULL) && Unity::LineOfSight(vector4, hitPositionWorld2, layerMask, melee_losforgiveness, 0.f, NULL);
		}
		ValidAttack = flag10;
	}
	return ValidAttack;
}

Projectile* prunk;

float DecyncVel(BasePlayer* target)
{
	if (!target)
		return target->GetMaxSpeed();

	DWORD64* mounted = (DWORD64*)Classes::get_mounted((DWORD64)target);
	if (mounted)
		return 25;

	return target->GetMaxSpeed();
}

float CalcTpVel(BasePlayer* target)
{
	if (!target)
		return 5.5;

	DWORD64* mounted = (DWORD64*)Classes::get_mounted((DWORD64)target);
	if (mounted)
		return 20;

	return target->GetMaxSpeed();
}

float CalcTpDistt()
{
	float num = 1.5f;
	float eye_clientframes = 2.0f;
	float eye_serverframes = 2.0f;
	float num2 = eye_clientframes / 60.0f;
	float num3 = eye_serverframes * max(Unity::get_deltaTime(), Unity::get_smoothDeltaTime(), Unity::get_fixedDeltaTime());
	float num4 = (0.05 + num2 + num3) * num;

	float magnitude = Target.Cur->GetParentVelocity().Magnitude() + CalcTpVel(Target.Cur) * 1.5;
	float num18 = Target.Cur->BoundsPadding() + num4 * magnitude + 0.2;

	return num18;
	float Dist = 0.1;

	if (Vars::Exploits::BulletTpType == 0)
		return 1;
	else if (Vars::Exploits::BulletTpType == 1)
		return 1.35;
	else if (Vars::Exploits::BulletTpType == 2)
		return 1.65;

	float num6 = (Dist + 2 / 60 + 0.03125f) * 1.5f;
	float maxdist = 0.1f + num6 * CalcTpVel(Target.Cur);


	return maxdist;
}

//float CalcTpDist()
//{
//	float num2 = 1.5;
//	float num3 = 1.5;
//	float projectile_clientframes = 2;
//	float projectile_serverframes = 2;
//
//	float num9 = projectile_clientframes / 60.f;
//	float num10 = projectile_serverframes * max(Unity::get_deltaTime(), Unity::get_smoothDeltaTime(), Unity::get_fixedDeltaTime());
//
//	float num12 = ((0.128 + num9 + num10) * num2);
//
//	float num15 = 5.5f + Target.Cur->GetParentVelocity().Magnitude();
//	//float magnitude = Target.Cur->GetParentVelocity().Magnitude;
//	float num16 = Target.Cur->BoundsPadding() + num12 * num15;
//	Vars::Exploits::BulletTpDist = num16;
//
//	return ;
//
//	/*if (Vars::Exploits::BulletTpType == 0)
//		return 1;
//	else if (Vars::Exploits::BulletTpType == 1)
//		return 1.35;
//	else if (Vars::Exploits::BulletTpType == 2)
//		return 1.65;*/
//
//	return Vars::Exploits::BulletTpDist;
//}

void UpdateHitTest(Projectile* unk, TraceInfo info, HitTest* ht) {
	//DWORD64 ht = unk->hitTestt();

	safe_write(ht + 0x66, true, bool); //DidHit
	safe_write(ht + 0x88, info.entity, BasePlayer*); //HitEntity
	safe_write(ht + 0xA8, info.distance, float); //HitDistance
	//

	safe_write(ht + 0xB8, info.partID, unsigned int); //HitPart
	safe_write(ht + 0xB0, info.bone, Transform*); //HitTransform
	safe_write(ht + 0x90, info.point, Vector3); //HitPoint
	safe_write(ht + 0x9C, info.normal, Vector3); //HitNormal
	safe_write(ht + 0x78, info.collider, Transform*); //collider

	typedef DWORD64(__stdcall* Ret)(DWORD64);
	//GameObject get_gameObject();
	DWORD64 go = info.collider != 0 ? get_gameObject(info.collider) : get_gameObject(info.bone);
	safe_write(ht + 0x70, go, DWORD64); //gameObject
	if (info.bone != 0) {
		typedef Vector3(__stdcall* ITP)(DWORD64, Vector3);
		Vector3 hitpoint = InverseTransformPoint((Transform*)safe_read(ht + 0xB0, DWORD64)/*HitTransform*/, info.point);
		safe_write(ht + 0x90, hitpoint, Vector3); //hitPoint

		Vector3 normalpoint = InverseTransformDirection((Transform*)safe_read(ht + 0xB0, DWORD64)/*HitTransform*/, info.normal);
		safe_write(ht + 0x9C, normalpoint, Vector3); //HitNormal
	}

}

bool canThrowAsProjectile = false;
bool SpearShot = false;
Vector3 AimVelRetard;
Vector3 ManipPosRetard;

struct TraceResult {
public:
	bool didHit;
	bool silentCat;
	BasePlayer* hitEntity;
	Vector3 hitPosition;
	Vector3 outVelocity;
	float hitTime;
	float hitDist;
	bool canHit;
	bool HasLOS;
};

class RayLine {
public:
	Vector3 start;
	Vector3 end;
	RayLine(Vector3 s, Vector3 e) {
		start = s; end = e;
	}
	RayLine() { }
	Vector3 ClosestPoint(Vector3 pos)
	{
		Vector3 a = end - start;
		float magnitude = a.Length();
		if (magnitude == 0.f) return start;
		Vector3 vector = a / magnitude;
		return start + vector * Maths::m_Clamp(Maths::Dot(pos - start, vector), 0.f, magnitude);
	}
};



//bool SilentCat(TraceResult& data, Vector3 LOSPoint)
//{
//	auto _this = (Projectile*)this;
//	float projectile_desync = vprojectile_desync1 - 0.05f;
//	Vector3 from = data.hitPosition;
//	Vector3 target = GetBounds((uintptr_t)data.hitEntity).m_center;
//	Vector3 initialTarget = target;
//	Vector3 velocity = data.outVelocity;
//	float desiredTime = data.hitTime;
//
//	float stepSize = 0.98f;
//	float needDist = from.distance(target);
//	int allowedUpdates = min((int)3.f, needDist / stepSize);
//
//	Vector3 dir = (target - from).Normalized() * stepSize;
//	Vector3 movPos = from;
//	Vector3 prevPos = movPos;
//
//	float time = unity::get_realtimesincestartup();//UnityEngine::Time::get_realtimeSinceStartup();
//	float maxTime = time - _this->launchTime();
//
//	if (maxTime >= 7.95f) {
//		_this->integrity(0.f);
//		return false;
//	}
//
//	//((ProtoBuf::PlayerProjectileUpdate*)g_UpdateReusable)->projectileID() = _this->projectileID();
//
//	constexpr float num = 0.03125f;
//	const float drag = _this->drag();
//	Vector3 gravity = Vector3(0.f, -9.81f * _this->gravityModifier(), 0.f);
//
//	bool first = true;
//	int updates = 0;
//
//	while (updates < allowedUpdates && movPos.distance(target) > stepSize) {
//		if (RPC_Counter.Calculate() >= 190)
//		{
//			break;
//		}
//		bool velocityChanged = false;
//		if (desiredTime + 0.0625f < min(maxTime + projectile_desync, 7.f))
//		{
//			desiredTime = desiredTime + 0.0625f;      //BRRRRRRRRRRRRRRRRR
//			velocityChanged = true;
//		}
//
//		float reduceLen = 0.f;
//		if (projectileProtection1 < 6)
//		{
//			Vector3 dir2 = (initialTarget - movPos).Normalized();
//			reduceLen = GetHitDist(min(maxTime, desiredTime), (BasePlayer*)data.hitEntity, true);
//			reduceLen = min(reduceLen, (initialTarget - from).Length());
//			target = initialTarget - dir2 * reduceLen;
//		}
//
//		bool done = false;
//		float pdst = movPos.distance(target);
//		if (pdst == 0.f) {
//			break;
//		}
//		else if (pdst < stepSize) {
//			movPos = target + (initialTarget - target).Normalized() * min(stepSize - pdst, reduceLen);
//			done = true;
//		}
//		else {
//			movPos = movPos + dir;
//		}
//
//		if (first) {
//			if (!PLOS(LOSPoint, movPos)) {
//				movPos = from;
//			}
//		}
//		first = false;
//
//		if (velocityChanged) {
//			Vector3 position = prevPos;
//			Vector3 prevPosition, prevVelocity;
//			for (int i = 0; i < 2; i++)
//			{
//				prevPosition = position;
//				prevVelocity = velocity;
//				position += velocity * num;
//				velocity += gravity * num;
//				velocity -= velocity * drag * num;
//			}
//			Vector3 b = prevVelocity * num;
//			Line1111 line = Line1111(prevPosition - b, position + b);
//			Vector3 closest = line.ClosestPoint(movPos);
//			Vector3 c = movPos - closest;
//			float len = c.Length();
//			if (len == 0.f)
//				movPos = closest;
//			else
//				movPos = closest + (c / len) * min(len, stepSize);
//		}
//
//		prevPos = movPos;
//
//		/*((protobuf::PlayerProjectileUpdate*)g_UpdateReusable)->position = movPos;
//		((protobuf::PlayerProjectileUpdate*)g_UpdateReusable)->velocity = velocity;
//		((protobuf::PlayerProjectileUpdate*)g_UpdateReusable)->traveltime = desiredTime;*/
//
//		//((ProtoBuf::PlayerProjectileUpdate*)g_UpdateReusable)->curPosition() = movPos;
//		//((ProtoBuf::PlayerProjectileUpdate*)g_UpdateReusable)->curVelocity() = velocity;
//		//((ProtoBuf::PlayerProjectileUpdate*)g_UpdateReusable)->travelTime() = desiredTime;
//
//		//SendPlayerProjectileUpdate(g_UpdateReusable);
//	//	RPC_Counter.Increment();
//
//		_this->sentPosition() = movPos;
//		_this->previoustraveledTime(desiredTime);
//		//_this->previousTraveledTime() = desiredTime;
//		_this->initialVelocity(velocity);
//		//_this->initialVelocity() = velocity;
//
//		data.hitTime = desiredTime;
//
//		_this->sentTraveledTime(desiredTime);
//		//_this->closeFlybyDistance() = desiredTime;
//		++updates;
//		if (done)
//			break;
//	}
//END:
//	bool flag = false;
//	float leftDist = min(movPos.distance(target), (initialTarget - movPos).Length());
//	if (leftDist < stepSize) {
//		data.hitPosition = movPos = movPos + (initialTarget - movPos).Normalized() * leftDist;
//		flag = true;
//	}
//	return flag;
//}
bool ValidatePr_(Projectile* pr, Vector3 modCurrent, Vector3 modPrevious, Vector3 hitPositionWorld) {
	if (!pr) return false;
	if (modCurrent.Empty()) return false;
	if (modPrevious.Empty()) return false;
	if (hitPositionWorld.Empty()) return false;
	if (!pr->IsAlive()) return false;
	if (pr->owner()->GetSteamID() != LocalPlayer->GetSteamID()) return false;
	if (pr->traveledTime() > 8.f) return false;
	if (pr->previousPosition().Distance(pr->currentPosition()) > 8900.f) return false;
	if (pr->currentPosition().Distance(modCurrent) > 1.f) return false;
	if (pr->currentPosition().Distance(modPrevious) > 1.f) return false;
	if (modCurrent.Distance(hitPositionWorld) > ((DWORD64*)Classes::get_mounted((DWORD64)Target.Cur) ? 14.f : 1.f)) return false;
	if (!Unity::CheckLOS(pr->currentPosition(), modCurrent, 0.1f)) return false;
	if (!Unity::CheckLOS(modCurrent, hitPositionWorld, 0.1f)) return false;

	return true;
}

Vector3 SimulateProjectile(Projectile* pr,Vector3& position, Vector3& velocity, float& partialTime, float travelTime, Vector3 gravity, float drag)
{
	float num = 0.03125f;
	Vector3 origin = position;
	if (partialTime > 0.f)
	{
		float num2 = num - partialTime;
		if (travelTime < num2)
		{
			origin = position;
			position += velocity * travelTime;
			partialTime += travelTime;
			return origin;
		}
		origin = position;
		position += velocity * num2;
		velocity += gravity * num;
		velocity -= velocity * drag * num;
		travelTime -= num2;
	}

	int num3 = Unity::FloorToInt(travelTime / num);

	for (int i = 0; i < num3; i++)
	{
		origin = position;
		position += velocity * num;
		velocity += gravity * num;
		velocity -= velocity * drag * num;
	}
	partialTime = travelTime - num * (float)num3;
	if (partialTime > 0.f)
	{
		origin = position;
		position += velocity * partialTime;
	}
	return origin;
}


Vector3 Simulate(Projectile* pr ,bool returnvelocity, bool sendtoserver) {
	Vector3 pos = pr->prevSentPosition(); Vector3 prev = pr->prevSentVelocity(); float part = pr->partialTime(); float travel = max(pr->traveledTime() - pr->sentTraveledTime(), 0.f);
	typedef Vector3(__stdcall* RetV)();
	Vector3 gr = Unity::get_gravity(); //static Vector3 get_gravity();


	Vector3 origin = SimulateProjectile(pr,pos, prev, part, travel, gr * pr->gravityModifier(), pr->Drag());

	if (sendtoserver) {

		pr->prevSentPosition(pos);
		pr->prevSentVelocity(prev);
		pr->partialTime(part);
		pr->sentTraveledTime(pr->traveledTime());
	}

	if (returnvelocity) return prev;

	return origin;
}

PlayerProjectileAttack* StorePPA;
PlayerAttack* StoreplayerAttack;
Attack* StoreAttack;
namespace BulletTeleport {

	uint64_t CreatePlayerProjectileUpdate()
	{
		typedef uint64_t(__stdcall* PoolGet)(uint64_t);
		uint64_t update = *reinterpret_cast<uint64_t*>(g_Base + offsets::Pool_Get_PlayerProjectileUpdate); // "Name": "Method$Facepunch.Pool.Get\u003CPlayerProjectileUpdate\u003E()",
		uint64_t projectileShoot = ((PoolGet)(g_Base + offsets::FacepunchPoolGetobject))(update);
		return projectileShoot;
	}

	uint64_t PoolGetPlayerProjectileAttack()
	{
		typedef uint64_t(__stdcall* PoolGet)(uint64_t);
		uint64_t update = *reinterpret_cast<uint64_t*>(g_Base + offsets::Pool_Get_PlayerProjectileAttack); // "Name": "Method$Facepunch.Pool.Get\u003CPlayerProjectileAttack\u003E()",
		uint64_t projectileShoot = ((PoolGet)(g_Base + offsets::FacepunchPoolGetobject))(update);
		return projectileShoot;
		/*auto PlayerProjectileAttack = reinterpret_cast<__int64(*)(__int64)>(g_Base + 0x10908e0);
		return PlayerProjectileAttack((g_Base + 50252136));*/
	}

	uint64_t PoolGetAttack()
	{
		typedef uint64_t(__stdcall* PoolGet)(uint64_t);
		uint64_t update = *reinterpret_cast<uint64_t*>(g_Base + offsets::Pool_Get_Attack); // "Name": "Method$Facepunch.Pool.Get\u003CAttack\u003E()",
		uint64_t projectileShoot = ((PoolGet)(g_Base + offsets::FacepunchPoolGetobject))(update);
		return projectileShoot;
	}

	//////////////////////////////////// IN DEVELOPMENT ////////////////////////////////////

	//Attack* BuildAttackMessage(HitTest* ht, Vector3 point)
	//{
	//	// BOOL RECREATED = TURE;

	//	if (!ht) return 0;

	//	unsigned int num = Vars::Aim::AimCombo == 0 ? 2173623152 : 1750816991;
	//	auto ppa = PoolGetPlayerProjectileAttack();

	//	Attack* attack = ((PlayerProjectileAttack*)ppa)->playerAttack->attack;
	//	attack->pointStart = ht->AttackRay()->origin;
	//	attack->pointEnd = ht->AttackRay()->origin + ht->AttackRay()->dir * ht->MaxDistance();
	//	// attack->hitMaterialID = num2;
	//	if (ht->DidHit())
	//	{
	//		if (ht->HitEntity())
	//		{
	//			Transform* transform = ht->HitTransform();
	//			if (transform)
	//			{
	//				/*if (!transform)
	//				{
	//					transform = this.HitEntity.transform;
	//				}*/
	//				attack->hitID = ht->HitEntity()->GetNet()->GetID();
	//				attack->hitBone = num;
	//				attack->hitPartID = ht->HitPart();
	//				attack->hitPositionWorld = point;// transform.localToWorldMatrix.MultiplyPoint(this.HitPoint);
	//				attack->hitPositionLocal = ht->HitPoint();
	//				attack->hitNormalWorld = point;
	//				attack->hitNormalLocal = ht->HitNormal();
	//			}
	//		}
	//	}
	//	return attack;
	//} // ohhh ye i want to kms 
	//  allll invalid letsss go man

	struct TraceInfo {

		bool valid; // 0x10
		float distance; // 0x14
		DWORD64 entity; // 0x18   //BasePlayer
		Vector3 point; // 0x20
		Vector3 normal; // 0x2C
		DWORD64/*Transform*/ bone; // 0x38
		DWORD64 material; // 0x40
		unsigned int partID; // 0x48
		Transform* collider; // 0x50
	};

	void UpdateHitTest(TraceInfo info, Projectile* pr) {
		DWORD64 ht = pr->hitTest();

		safe_write(ht + 0x66, true, bool); //DidHit
		safe_write(ht + 0x88, info.entity, DWORD64); //HitEntity
		safe_write(ht + 0xA8, info.distance, float); //HitDistance
		//

		//typedef pUncStr(__stdcall* GetName)(DWORD64);
		//if (info.material != 0) {
		//	pUncStr material = (pUncStr)(((GetName)(g_Base + O::AssetNameCache::GetName))(info.material));
		//	safe_write(ht + 0xC0, material, pUncStr); //HitMaterial  
		//}
		safe_write(ht + 0xB8, info.partID, unsigned int); //HitPart
		safe_write(ht + 0xB0, info.bone, DWORD64); //HitTransform
		safe_write(ht + 0x90, info.point, Vector3); //HitPoint
		safe_write(ht + 0x9C, info.normal, Vector3); //HitNormal
		safe_write(ht + 0x78, info.collider, Transform*); //collider

		typedef DWORD64(__stdcall* Ret)(DWORD64);
		//GameObject get_gameObject();
		DWORD64 go = info.collider != 0 ? get_gameObject(info.collider) : get_gameObject((Transform*)info.bone);
		safe_write(ht + 0x70, go, DWORD64); //gameObject
		if (info.bone != 0) {
			typedef Vector3(__stdcall* ITP)(DWORD64, Vector3);
			Transform* HitTransform = Read<Transform*>(ht + 0xB0);
			Vector3 hitpoint = InverseTransformPoint(HitTransform, info.point);
			safe_write(ht + 0x90, hitpoint, Vector3); //hitPoint

			Vector3 normalpoint = InverseTransformDirection(HitTransform, info.normal);
			safe_write(ht + 0x9C, normalpoint, Vector3); //HitNormal
		}

	}
	inline bool TestNoClipping(Vector3 oldPos, Vector3 newPos, float radius, bool sphereCast, int num1 = 429990145) {
		int num = num1;

		Vector3 normalized = (newPos - oldPos).Normalized();
		Vector3 vector = oldPos - normalized;
		float magnitude = (newPos - vector).Magnitude();
		bool flag{};
		if (sphereCast) {
			typedef bool (*AAA)(Ray, float, float, int);
			flag = ((AAA)(g_Base + offsets::o_SphereCast))(Ray(vector, normalized), radius, magnitude, num);/*Unity::SphereCast(Ray(vector, normalized), radius, magnitude, num);*/
		}
		return flag;
	}


	bool DoBigBullet(Projectile* projectile, Vector3 point) {
		projectile->ricochetChance(0.f);
		if (!Vars::Exploits::BulletTp)
			return false;

		if (!Target.Cur)
			return false;

		float bigBulletSize = 2.4f;
		Vector3 bulletPos = point;
		Transform* boneTransform = Target.Cur->GetTransform(47); if (!boneTransform) return false;

		Vector3 playerPos = boneTransform->Position();
		//UnityEngine::DDraw::Sphere(bulletPos, 0.05f, Color(255, 255, 255, 255).ToUnityColor(), 2.5f, false);
		if (playerPos.Distance(bulletPos) > bigBulletSize) return false;

		Vector3 movedPos = Vector3::MoveTowards(bulletPos, playerPos, 0.999999999999999999f);
		if (!Unity::CheckLOS(Target.Pos, movedPos) || !Unity::CheckLOS(projectile->get_transform()->Position(), playerPos)) return false;

		projectile->get_transform()->SetBonePos(movedPos); if (playerPos.Distance(bulletPos) > ((bigBulletSize - 0.999999999999999999f) + 0.05f)) return false;

		HitTest* hTest = projectile->get_hit_test(); if (!hTest) return false;

		hTest->DidHit(true);
		hTest->HitEntity(Target.Cur);
		hTest->HitDistance(playerPos.Distance(bulletPos));
		hTest->HitTransform(boneTransform);
		hTest->HitPoint(InverseTransformPoint(boneTransform,movedPos));
		hTest->AttackRay(Ray(bulletPos, (playerPos - bulletPos).Normalized()));

		return DoHit(projectile, hTest, hTest->HitPoint(), Vector3(0.f, 0.f, 0.f));
	}

	bool TpBulletHitsP2(Projectile* pr, Vector3 curPosit, Vector3 point, HitTest* hitTest)
	{
		// VMProtectBegin
		if (Vars::Exploits::BulletTp/* && !Vars::Exploits::UknMeme*/)
		{
			BasePlayer* lastTarget = Target.Cur;
			Vector3 targetPos = Classes::CenterPoint(Target.Cur) + Vector3(0, 0.2, 0);
			HitTest* hitTest = pr->get_hit_test();
			float num25 = 0.f;
			float num26 = lastTarget->GetParentVelocity().Magnitude();
			num25 = ((min(Unity::RealtimeSinceStartup() - LocalPlayer->lastSentTickTime(), 1) + (AntiHack::projectile_clientframes / 60) + (AntiHack::projectile_serverframes * max(Unity::get_deltaTime(), max(Unity::get_smoothDeltaTime(), Unity::get_fixedDeltaTime())))) * 1.5) * num26;
			RayLine line = RayLine(pr->previousPosition() - pr->previousVelocity(), pr->currentPosition() + pr->previousVelocity()); //prev pos, prev vel
			float num28 = max((targetPos - line.ClosestPoint(targetPos)).Magnitude() - num25, 0.f);
			float ScanRange = (Vars::Exploits::BulletTpExternded ? 6 : Vars::Exploits::BulletTpDist);
			if (Maths::Calc3D_Dist(point, targetPos) <= ScanRange)
			{
				// VMProtectBeginVirtualization(_("понос"));

				if (Unity::CheckLOS(point, Target.Cur->GetEyes()->GetCenter()) && !TestNoClipping(point, targetPos, 0.001, true))
				{
					Transform* PlayerTrans = Vars::Aim::AimCombo == 0 ? lastTarget->GetTransform(47) : lastTarget->GetTransform(22);
					Vector3 newPosition = Vector3::MoveTowards(point, targetPos, min(num28, 0.99));

					if (PlayerTrans) {
						float distToHead = Maths::Calc3D_Dist(point, targetPos);
						int projID = pr->projectileID();
						auto ppu = CreatePlayerProjectileUpdate();
						((PlayerProjectileUpdate*)ppu)->projectileID = projID;
						((PlayerProjectileUpdate*)ppu)->curPosition = point;

						((PlayerProjectileUpdate*)ppu)->curVelocity = pr->currentVelocity();
						((PlayerProjectileUpdate*)ppu)->travelTime = pr->traveledTime();
						LocalPlayer->SendProjectileUpdate(ppu);
						pr->sentPosition(point);

						ppu = CreatePlayerProjectileUpdate();
						((PlayerProjectileUpdate*)ppu)->projectileID = projID;
						((PlayerProjectileUpdate*)ppu)->curPosition = newPosition;
						((PlayerProjectileUpdate*)ppu)->curVelocity = pr->currentVelocity();
						((PlayerProjectileUpdate*)ppu)->travelTime = pr->traveledTime() + distToHead / pr->currentVelocity().Magnitude();
						LocalPlayer->SendProjectileUpdate(ppu);

						pr->traveledDistance(pr->traveledDistance() + distToHead);
						pr->traveledTime(pr->traveledTime() + distToHead / pr->currentVelocity().Magnitude());

						hitTest->AttackRay(Ray(newPosition, (targetPos - newPosition).Normalized()));
						hitTest->HitTransform(PlayerTrans);
						hitTest->HitEntity(Target.Cur);
						hitTest->HitPoint(InverseTransformPoint(PlayerTrans, targetPos));
						hitTest->HitNormal(InverseTransformDirection(PlayerTrans, newPosition));
						hitTest->DidHit(true);

						return DoHit(pr, hitTest, targetPos, targetPos - newPosition);
					}
				}

				// VMProtectEnd();
			}
		}

		return false;


	}
	

}

//__int64* __
// call sub_180268E90(__int64 element_class_0)
//{
//	__int64 v2; // rsi
//	__int64* v3; // rax
//	__int64* v4; // rdi
//	char* v5; // rcx
//	char* v6; // rax
//	unsigned __int64 v7; // r8
//	__int64 v8; // rcx
//	__int64* v9; // rax
//
//	sub_1802A1760();
//	if ((unsigned __int8)sub_1802A2EB0(element_class_0))
//		element_class_0 = mono_class_get_element_class_0(element_class_0);
//	if ((*(_BYTE*)(element_class_0 + 306) & 0x20) != 0)
//	{
//		v8 = *(unsigned int*)(element_class_0 + 248);
//		if (*(_QWORD*)(element_class_0 + 8))
//		{
//			v9 = (__int64*)sub_18030FB70(v8, element_class_0);
//		}
//		else
//		{
//			v9 = (__int64*)sub_180312670(v8);
//			*v9 = element_class_0;
//		}
//		v4 = v9;
//	}
//	else
//	{
//		v2 = *(unsigned int*)(element_class_0 + 248);
//		v3 = (__int64*)sub_180312680(v2);
//		v4 = v3;
//		*v3 = element_class_0;
//		v5 = (char*)(v3 + 2);
//		v3[1] = 0i64;
//		if ((unsigned int)v2 >= 0x80)
//		{
//			memset(v5, 0, v2 - 16);
//		}
//		else
//		{
//			v6 = (char*)v3 + v2;
//			v7 = (unsigned __int64)(v6 - v5 + 7) >> 3;
//			if (v5 > v6)
//				v7 = 0i64;
//			if (v7)
//				memset(v5, 0, 8 * v7);
//		}
//	}
//	_InterlockedIncrement64(&qword_1831204E8);
//	if ((*(_BYTE*)(element_class_0 + 307) & 2) != 0)
//		sub_1803041E0(v4);
//	if ((dword_183120160 & 0x80) != 0)
//		sub_1802B3640(v4, element_class_0);
//	il2cpp_runtime_class_init_0(element_class_0);
//	return v4;
//}


//Vector3 RealPosition = point;
//Vector3 newPosition = Vector3::MoveTowards(Target.Cur->GetEyes()->EyePosition(), point, 0.99);
//point = newPosition;
//
//float dist = RealPosition.Distance(newPosition);
//
//auto ppu = CreatePlayerProjectileUpdate();
//((PlayerProjectileUpdate*)ppu)->projectileID = pr->projectileID();
//((PlayerProjectileUpdate*)ppu)->curPosition = point;
//((PlayerProjectileUpdate*)ppu)->curVelocity = pr->currentVelocity();
//// pr->previousPosition(newPosition);
////pr->currentPosition(newPosition);
//((PlayerProjectileUpdate*)ppu)->travelTime = pr->traveledTime() + dist / pr->currentVelocity().Length();
//LocalPlayer->SendProjectileUpdate(ppu);
//
//
//
//pr->traveledDistance(pr->traveledDistance() + dist);
//pr->traveledTime(pr->traveledTime() + dist / pr->currentVelocity().Length());
//
////HitTest* hitTest = pr->get_hit_test();
//
////hitTest->AttackRay(Ray(point, newPosition));
////hitTest->HitTransform(PlayerTrans);
////hitTest->HitEntity(Target.Cur);
////hitTest->HitPoint(InverseTransformPoint(PlayerTrans, newPosition));
////hitTest->HitNormal(Vector3(0, 0, 0));
/////*hitTest->HitPart(boneId);
////hitTest->MaxDistance(999);*/
////hitTest->DidHit(true);
////
//////public Attack BuildAttackMessage() { }
//
////DoHit(pr, hitTest, newPosition, Vector3(0, 0, 0));
////BuildAttackMessage(hitTest);
//
////return true;
//
//HitTest* hitTest = pr->get_hit_test();
//
//Vector3 hitPosition = Vector3::MoveTowards(newPosition, Target.Pos, 0.99);
//
//hitTest->AttackRay(Ray(point, hitPosition));
//hitTest->HitTransform(PlayerTrans);
//hitTest->HitEntity(Target.Cur);
//hitTest->HitPoint(InverseTransformPoint(PlayerTrans, hitPosition));
//hitTest->HitNormal(Vector3(0, 0, 0));
//hitTest->DidHit(true);
//DoHit(pr, hitTest, point, Vector3(0, 0, 0));
//// BuildAttackMessage(hitTest);

void UpdateVelocity1(float deltaTime, Projectile* pr, bool& rett) {
	if (pr->traveledTime() != 0.f) {
		pr->previousPosition(pr->currentPosition());
		pr->previoustraveledTime(pr->traveledTime());
	}
	typedef DWORD64(__stdcall* Ret)(DWORD64);
	Transform* Transf = pr->get_transform();
	Vector3 pos = Transf->Position();
	pr->currentPosition(pos);

	typedef float(__stdcall* RetFEmpty)();
	if (pr->traveledTime() == 0.f) {
		pr->sentPosition(pos);
		pr->previousPosition(pos);
		pr->partialTime(0.f); pr->sentTraveledTime(0.f);  pr->prevSentVelocity(pr->InitialVelocity()); pr->prevSentPosition(pr->sentPosition()); pr->needsLOS(false);
	}

	//deltaTime *= get_timeScale();



	bool ret = DoMovement(pr, deltaTime);
	if (!ret) {
		DoVelocityUpdate(pr, deltaTime);
	}
	/*if (!DoMovement(pr, deltaTime))
	{
		DoVelocityUpdate(pr, deltaTime);
	}*/

	typedef void(__stdcall* SetP)(DWORD64, Vector3);
	typedef DWORD64(__stdcall* GetTr)(DWORD64);

	Transform* Trans = pr->get_transform(); //Component | Transform get_transform(); 
	Classes::set_position(Trans, pr->currentPosition()); //Transform | void set_position(Vector3 value); 

	Vector4 rotation = LookRotation(pr->currentVelocity(), Vector3(0, 1, 0));
	set_rotation(Trans, rotation);
}

bool LineCircleIntersectionPredict(Vector3 center, float radius, Vector3 rayStart, Vector3 rayEnd, float* offset)
{
	Vector2 P(rayStart.x, rayStart.z);
	Vector2 Q(rayEnd.x, rayEnd.z);

	float a = Q.y - P.y;
	float b = P.x - Q.x;
	float c = (a * (P.x) + b * (P.y)) * -1.f;

	float x = center.x;
	float y = center.z;

	float c_x = (b * ((b * x) - (a * y)) - a * c) / (powFFFFFFFFFFFFFFFFFFFFFF(a, 2) + powFFFFFFFFFFFFFFFFFFFFFF(b, 2));
	float c_y = (a * ((-b * x) + (a * y)) - (b * c)) / (powFFFFFFFFFFFFFFFFFFFFFF(a, 2) + powFFFFFFFFFFFFFFFFFFFFFF(b, 2));

	Vector2 closestPoint(c_x, c_y);

	float distance = P.Distance(Q);

	if (P.Distance(closestPoint) > distance || Q.Distance(closestPoint) > distance)
	{
		return false;
	}

	if (radius > closestPoint.Distance(Vector2(center.x, center.z)))
	{
		Vector2 P(rayStart.x, rayStart.y);
		Vector2 Q(rayEnd.x, rayEnd.y);

		float a = Q.y - P.y;
		float b = P.x - Q.x;
		float c = (a * (P.x) + b * (P.y)) * -1.f;

		float x = center.x;
		float y = center.y;

		float c_x = (b * ((b * x) - (a * y)) - a * c) / (powFFFFFFFFFFFFFFFFFFFFFF(a, 2) + powFFFFFFFFFFFFFFFFFFFFFF(b, 2));
		float c_y = (a * ((-b * x) + (a * y)) - (b * c)) / (powFFFFFFFFFFFFFFFFFFFFFF(a, 2) + powFFFFFFFFFFFFFFFFFFFFFF(b, 2));

		Vector2 closestPoint(c_x, c_y);
		if (radius > closestPoint.Distance(Vector2(center.x, center.y)))
		{
			return true;
		}
		else
		{
			*offset = (closestPoint.Distance(P) / distance);
			return false;
		}
	}

	return false;
}


//Vector3 GetEndPointForTrajectory(float speed, float angle, float drag, float gravityMod)
//{
//	float pitchRad = DEG2RAD(angle);
//
//	Vector3 dir = {
//		(float)(sinf(90.f) * cosf(pitchRad)),
//		(float)sinf(pitchRad),
//		(float)(cosf(90.f) * cosf(pitchRad))
//	};
//
//	Vector3 position = Vector3();
//	Vector3 velCheck = dir * speed;
//
//	const float stepSize = 0.03125f;
//
//	for (float travelTime = 0.f; travelTime < 8.f; travelTime += stepSize)
//	{
//		position += velCheck * stepSize;
//		velCheck.y -= 9.81f * gravityMod * stepSize;
//		velCheck -= velCheck * drag * stepSize;
//	}
//
//	return position;
//}

//Vector2 insideUnitCircle() {
//	int rand = Maths::my_rand() % 1000;
//	float gen = rand / 1000;
//
//	float angle = 2.f * M_PI * gen;
//	float distance = Maths::m_Sqrt(gen);
//
//	float x = distance * Maths::m_Cos(angle);
//	float y = distance * Maths::m_Sin(angle);
//
//	return Vector2(x, y);
//}

float getLerp(Vector3 Center, Vector3 FirstPosition, Vector3 LastPosition) {

	Vector3 Center2D = Center; Vector3 First2D = FirstPosition; Vector3 Last2D = LastPosition; //Sets Nessasary Positions Whilst Ignoring Y-Axis
	Center2D.y = 0.f; First2D.y = 0.f; Last2D.y = 0.f;

	// calculate the distances between the vectors in 2D space
	float distanceFromFirst = (Center2D - First2D).Magnitude();
	float distanceFromLast = (Center2D - Last2D).Magnitude();

	// calculate the total distance between the FirstPosition and LastPosition vectors in 2D space
	float totaldistance = (Last2D - First2D).Magnitude();

	// if the total distance is 0, return 0.5 (Center is exactly in the middle)
	if (totaldistance == 0) {
		return 0.5;
	}
	else {
		// calculate the percentage of the distance between Center and the two positions in 2D space
		float percentFromFirst = distanceFromFirst / totaldistance;
		float percentFromLast = distanceFromLast / totaldistance;

		// calculate the lerp value
		float lerpValue = percentFromFirst / (percentFromFirst + percentFromLast);
		return lerpValue;
	}
}

struct BulletDropPredictionData
{
	float distCoeff;
	float startY;
	float yCoeff;
};

BulletDropPredictionData bulletDropData[11];

Vector3 GetEndPointForTrajectory(float speed, float angle, float drag, float gravityMod)
{
	float pitchRad = DEG2RAD(angle);

	Vector3 dir = {
							(float)(Maths::m_Sin(90) * Maths::m_Cos(pitchRad)),
							(float)Maths::m_Sin(pitchRad),
							(float)(Maths::m_Cos(90) * Maths::m_Cos(pitchRad))
	};

	Vector3 position = Vector3();
	Vector3 velCheck = dir * speed;

	const float stepSize = 0.03125f;

	for (float travelTime = 0.f; travelTime < 8.f; travelTime += stepSize)
	{
		position += velCheck * stepSize;
		velCheck.y -= 9.81f * gravityMod * stepSize;
		velCheck -= velCheck * drag * stepSize;
	}

	return position;
}

void GenerateBuilletDropPredictionData(float drag, float gravityMod)
{
	int currentIndex = 0;
	for (float angle = 35.f; angle <= 85.f; angle += 5.f)
	{
		BulletDropPredictionData& predData = bulletDropData[currentIndex++];

		Vector3 a1 = GetEndPointForTrajectory(30.f, angle, drag, gravityMod);
		Vector3 a2 = GetEndPointForTrajectory(50.f, angle, drag, gravityMod);

		predData.distCoeff = a2.Length() / 50.f;
		predData.startY = a1.y;
		predData.yCoeff = (a2.y - a1.y) / 20.f;
	}
}

float LowVeloPredict(Vector3 initialVelocity, float angle, float drag, float gravityMod, Vector3& targetPos)
{
	float pitchRad = DEG2RAD(angle);

	Vector3 dir = {
		(float)(Maths::m_Sin(90) * Maths::m_Cos(pitchRad)),
		(float)Maths::m_Sin(pitchRad),
		(float)(Maths::m_Cos(90) * Maths::m_Cos(pitchRad))
	};

	float speed = initialVelocity.Magnitude(); // make sure this is base value from projectile, not modified in any way

	Vector3 position = Vector3();
	Vector3 velCheck = dir * speed;
	const float stepSize = 0.03125f;
	float highestScale = 1.0f;
	float optimalAngle = angle;
	float minTravelTime = 9;

	for (float scale = 1.49f; scale >= 0.01f; scale -= 0.01f)
	{
		velCheck = dir * (speed * scale);

		bool collision = false;
		float travelTime = 0.0f;
		for (; travelTime < 8.0f; travelTime += stepSize)
		{
			Vector3 newPos = position + velCheck * stepSize;
			if (!Unity::CheckLOS(position, newPos))
			{
				collision = true;
				break;
			}

			position = newPos;
			velCheck.y -= 9.81f * gravityMod * stepSize;
			velCheck -= velCheck * drag * stepSize;
		}

		if (!collision && travelTime < minTravelTime)
		{
			minTravelTime = travelTime;
			highestScale = scale;
			optimalAngle = angle;
			targetPos = position;
		}

		angle -= 1.0f; // adjust angle for the next iteration
		pitchRad = DEG2RAD(angle);
		dir = {
							(float)(Maths::m_Sin(90) * Maths::m_Cos(pitchRad)),
							(float)Maths::m_Sin(pitchRad),
							(float)(Maths::m_Cos(90) * Maths::m_Cos(pitchRad))
		};
		position = Vector3();
		velCheck = dir * speed;
	}

	return optimalAngle;
}


Vector3 GetTrajectoryForEndPoint(Vector3 TargetPos, Vector3 InitialPos, float Velocity, float Drag, float GravityMulti, float initialDistance, bool* Sims_finished, float* TravelTime)
{
	bool SimulationFinished = false;
	int MaximumSims = 30;

	float PitchOffset = 0;
	Vector3 TargetPostion = TargetPos;
	Vector3 OutputAngle;

	for (int i = 0; i < MaximumSims; i++)
	{
		TargetPostion.y += PitchOffset;
		// lvAngle
		Vector3 newAngle = TargetPostion - InitialPos;
		Vector3 Angle = Classes::GetModifiedAimCone(0, TargetPostion - InitialPos, false);// TargetPostion - InitialPos;

		Vector3 CalcVelocity = Angle.Normalized() * Velocity;

		Vector3 ProjectilePosition = InitialPos;
		Vector3 PreviousPosition = Vector3();

		const float StepSize = 0.03125f;
		for (float travelTime = 0; travelTime < 8; travelTime += StepSize)
		{
			PreviousPosition = ProjectilePosition;
			ProjectilePosition = ProjectilePosition + (CalcVelocity * StepSize);

			CalcVelocity.y -= 9.81f * GravityMulti * StepSize;
			CalcVelocity -= CalcVelocity * Drag * StepSize;

			float IntersectionPoint; // 0.01f
			if (LineCircleIntersectionPredict(TargetPos, 0.05f, PreviousPosition, ProjectilePosition, &IntersectionPoint)) {
				SimulationFinished = true;

				if (travelTime > 0.1 && InitialPos.Distance(ProjectilePosition) > initialDistance) {
					*TravelTime = travelTime - (((getLerp(TargetPostion, ProjectilePosition, PreviousPosition) * StepSize)) + (initialDistance / Velocity));
				}
				break;
			}
			else if (InitialPos.Distance(TargetPos) < InitialPos.Distance(ProjectilePosition)) {
				Vector3 CalculatedPosition = Vector3(TargetPos.x, Maths::Lerp(ProjectilePosition.y, PreviousPosition.y, getLerp(TargetPostion, ProjectilePosition, PreviousPosition)), TargetPos.z);
				PitchOffset = TargetPos.y - CalculatedPosition.y;
				break;
			}
		}

		if (SimulationFinished)
			break;
	}
	*Sims_finished = SimulationFinished;
	return TargetPostion;
}

Vector3 bVel{};
bool Predicted1 = false;
float TravelTime1 = 0;

Vector3 calculateDragForce(const Vector3& velocity, float dragCoefficient) {
	float speed = Maths::m_Sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z);
	return velocity * (-dragCoefficient * speed);
}

Vector3 simulateMotion(const Vector3& initialPosition, const Vector3& initialVelocity, float GravityMulti, float dragCoefficient, float deltaTime, float totalTime) {
	Vector3 position = initialPosition;
	Vector3 velocity = initialVelocity;

	for (float t = 0; t < totalTime; t += deltaTime) {
		position += velocity * deltaTime;
		velocity.y -= 9.81f * GravityMulti * deltaTime;
		velocity -= velocity * dragCoefficient * deltaTime;
	}

	return position;
}

Vector3 GetLineImpact(Vector3 start, Vector3 end) {
	const float stepSize = 0.1f;
	Vector3 currentPoint = start;

	while (currentPoint.Distance(end) > stepSize) {
		currentPoint += (end - start).Normalized() * stepSize;

		if (Unity::CheckLOS(currentPoint, end)) {
			return currentPoint;
		}
	}

	return end;
}
Vector3 GetNextPointForTrajectory(Vector3 currentPosition, Vector3 currentVelocity, float drag, float gravityMod)
{
	Vector3 position = currentPosition;
	Vector3 velCheck = currentVelocity;

	const float stepSize = 0.03125f;

	position += velCheck * stepSize;
	velCheck.y -= 9.81f * gravityMod * stepSize;
	velCheck -= velCheck * drag * stepSize;

	return position;
}

bool ShootingThoughTheWalls(Projectile* pr, float precision)
{
	Vector3 currentPosition = pr->currentPosition();
	Vector3 nextPosition = GetNextPointForTrajectory(currentPosition, pr->currentVelocity(), pr->Drag(), pr->gravityModifier());
	Vector3 targetPosition = Target.Pos;
	if (!Unity::CheckLOS(currentPosition, nextPosition)) {
		Vector3 external = GetLineImpact(currentPosition, nextPosition);
		Vector3 point = Vector3::MoveTowards(external, nextPosition, 0.3125f);

		pr->currentPosition(point);
		pr->previousPosition(point);

		Update(pr);

		if (Unity::CheckLOS(nextPosition, targetPosition))
		{
			return true;
		}
	}
	else return false;
}


bool StwCheck(Projectile* pr)
{
	if (Vars::Exploits::stw) {
		//float scan_strength = 0.45f / (Vars::Exploits::stw_scans + 1);
		//if (ShootingThoughTheWalls(pr, 0.1)) {
		//	return true;
		//}
	}

	return false;
}

bool MagicBulletUkn(Projectile* pr, Vector3 curPosit)
{
	if (Vars::Exploits::UknMeme)
	{
		Transform* PlayerTrans = Target.Cur->GetTransform(47);
		HitTest* hitTest = pr->get_hit_test();
		hitTest->AttackRay(Ray(pr->currentPosition(), PlayerTrans->Position()));
		hitTest->HitTransform(PlayerTrans);
		hitTest->HitEntity(Target.Cur);
		hitTest->HitPoint(InverseTransformPoint(PlayerTrans, PlayerTrans->Position()));
		hitTest->HitNormal(Vector3(0, 0, 0));
		hitTest->DidHit(true);
		return DoHit(pr, hitTest, PlayerTrans->Position(), Vector3(0, 0, 0));
	}

	return false;
}

//void MyUpdateVelocity(Projectile* pr, float deltaTime)
//{
//	if (pr->traveledTime() != 0.f)
//	{
//		pr->previousPosition(pr->currentPosition());
//		pr->previousTraveledTime(pr->traveledTime());
//	}
//	pr->currentPosition() = pr->get_transform()->Position();
//	if (pr->traveledTime() == 0.f)
//	{
//		pr->sentPosition() = (pr->previousPosition() = pr->currentPosition());
//	}
//	deltaTime *= Unity::get_timeScale();
//	DoMovement(pr, deltaTime);
//	DoVelocityUpdate(pr, deltaTime);
//	pr->get_transform()->SetBonePos(pr->currentPosition());
//	/*if (pr->tumbleSpeed() > 0.f)
//	{
//		base.transform.Rotate(pr->tumbleAxis, pr->tumbleSpeed * deltaTime);
//		return;
//	}*/
//	set_rotation(pr->get_transform(), LookRotation(pr->currentVelocity(), pr->currentVelocity()));
//}

void UpdateProjectile_Hook(Projectile* pr)
{
	if (!pr) return;

	// pr->ricochetChance(999);
	//Retire(pr);

	PrUpdate = pr;
	if (get_isAuthoritative(pr)) {
		if (get_isAlive(pr)) {


			ProjectileShootInited = true;
			ProjectileDrag = pr->Drag();
			ProjectileInitialDistance = pr->initialDistance();
			ProjectilegravityModifier = pr->gravityModifier();

			Vector3 vector2 = pr->currentVelocity() * 0.03125;
			float magnitude = vector2.Magnitude();
			float num2 = 1.f / magnitude;
			Vector3 vector3 = vector2 * num2;
			bool flag = false;
			Vector3 vector4 = pr->currentPosition() + vector3 * magnitude;
			//pr->currentPosition(vector4);
			//DoMovement(pr, 0.03125);
		}
	}

	//bool trajectoryMismatch(Projectile * firedProjectile, Vector3 position, Vector3 HitWorldPosition, Vector3 * outPoint)
	//{
	//	float num = 0; // trajectory miss match
	//	int num12 = 2162688;
	//	if (AntiHack::projectile_terraincheck)
	//	{
	//		num12 |= 8388608;
	//	}
	//	//if (AntiHack::projectile_protection > 0)
	//	//{
	//	//	if (AntiHack::projectile_protection >= 1)
	//	//	{
	//	//		if (AntiHack::projectile_protection >= 3)
	//	//		{
	//	//			Vector3 position2 = position;
	//	//			Vector3 curPosition = position;
	//	//			Vector3 vector = Vector3::Zero();
	//	//			if (AntiHack::projectile_backtracking > 0.f)
	//	//			{
	//	//				vector = (curPosition - position2).Normalized() * AntiHack::projectile_backtracking;
	//	//			}
	//	//			if (!Unity::LineOfSight(position2 - vector, curPosition + vector, num12, 0.18, 0,0))
	//	//			{
	//	//				return false;
	//	//			}
	//	//		}

	//	Vector3 vector2;
	//	Vector3 vector3;

	//	vector2 = Simulate(firedProjectile, false, false);
	//	vector3 = Simulate(firedProjectile, true, false);

	//	if (AntiHack::projectile_protection >= 4)
	//	{
	//		// SimulateProjectile(position, ref velocity, ref partialTime, num2 - travelTime, gravity, drag, out vector2, out vector3);
	//		Vector3 vector4 = vector3 * 0.03125f;
	//		RayLine line = RayLine(vector2 - vector4, position + vector4);
	//		Vector3 closestPoint = line.ClosestPoint(position);
	//		num += closestPoint.Distance(position);
	//		if (num > AntiHack::projectile_trajectory)
	//		{
	//			// trajectory
	//			// OnProjectileUpdate check
	//			LocalPlayer->ConsoleMsg(_(L"projectile_trajectory"));
	//			Update(firedProjectile);
	//			return false;
	//		}
	//	}

	//	if (AntiHack::projectile_protection >= 4)
	//	{
	//		// SimulateProjectile(position, ref velocity, ref partialTime, num2 - travelTime, gravity, drag, out vector2, out vector3);
	//		Vector3 vector4 = vector3 * 0.03125f;
	//		RayLine line = RayLine(vector2 - vector4, position + vector4);
	//		Vector3 closestPoint = line.ClosestPoint(position);
	//		float num24 = closestPoint.Distance(HitWorldPosition);
	//		if (num24 > AntiHack::projectile_trajectory)
	//		{
	//			float diff = num24 - AntiHack::projectile_trajectory;
	//			// trajectory_end
	//			wchar_t outputText[512];
	//			f_swprint(outputText, _(L"%f"), diff);
	//			LocalPlayer->ConsoleMsg(outputText);
	//			*outPoint = Vector3::MoveTowards(HitWorldPosition, position, diff);
	//			//Update(firedProjectile);
	//			return false;
	//		}
	//	}
	//	return true;
	//}


	/*if (get_isAuthoritative(pr)) {
		if (get_isAlive(pr)) {
			StwCheck(pr);
		}
	}*/

	if (Vars::Exploits::BulletTp || Vars::Exploits::MeleePsilent || Vars::Exploits::UknMeme || Vars::Exploits::HeliMagic)
	{
		if (get_isAuthoritative(pr)) {
			if (get_isAlive(pr)) {
				//for (Projectile* i = pr; get_isAlive(i); UpdateVelocity(i, 0.03125))
				{
					//Classes::DDrawSphere(pr->get_transform()->Position(), 0.1f, Color(0, 1, 0, 1), 5, true);
					if (!Target.Heli && !Target.Turret && Target.Cur)
					{
						Vector3 vector2 = pr->currentVelocity() * 0.03125;
						float magnitude = vector2.Magnitude();
						float num2 = 1.f / magnitude;
						Vector3 vector3 = vector2 * num2;
						Vector3 vector4 = pr->currentPosition() + vector3 * magnitude;
						RayLine line = RayLine(pr->currentPosition(), vector4);

						Vector3 FirstNearest = line.ClosestPoint(Target.Pos);
						float DistanceToPoint1 = FirstNearest.Distance(Target.Pos);

						bool didUknMeme = false;
						if (!MagicBulletUkn(pr, pr->currentPosition())) {
							float ScanRange = (Vars::Exploits::BulletTpExternded ? 6 : Vars::Exploits::BulletTpDist) * 1.05;
							if (DistanceToPoint1 < 3)
							{
								bool didTp = false;

								for (Projectile* i = pr; get_isAlive(i); UpdateVelocity(i, 0.00025))
								{
									BulletTeleport::DoBigBullet(i, i->currentPosition());
									if (BulletTeleport::TpBulletHitsP2(i, i->currentPosition(), i->currentPosition(), 0))
										didTp = true;

									if (i->launchTime() <= 0) {
										break;
									}

									float time = get_time();

									if (time - i->launchTime() < i->traveledTime() + 0.03125f) {
										break;
									}
								}
							}

							if (Vars::Exploits::MeleePsilent)
							{
								Vector3 EyePsoition = LocalPlayer->GetEyes()->EyePosition();
								Vector3 RealEyePsoition = LocalPlayer->GetEyes()->EyePosition();

								if (Vars::Exploits::Manipulation && Manipulating) {
									EyePsoition += ManipulationAngle;
								}
								else if (EyePsoition != RealEyePsoition)
								{
									EyePsoition = RealEyePsoition;
								}

								if (pr->initialDistance() >= pr->traveledDistance() && pr->traveledTime() <= 0.15f) {

									if (isPredicted)
									{
										if (bVel != Vector3::Zero())
										{
											pr->currentVelocity(bVel);
											pr->get_transform()->SetBonePos(EyePsoition);
											pr->currentPosition(EyePsoition);
										}
									}
									else
									{
										bVel = Vector3();
									}
								}
							}
						}

					}
					else if (Target.Heli && Target.Cur && Vars::Exploits::HeliMagic)
					{
						
						//if (Maths::Calc3D_Dist(point, heliPos) < 20) {

						//	Transform* heliTransform = Target.Cur->get_transform();

						//	float Dist2Heli = Maths::Calc3D_Dist(point, heliPos);
						//	int projID = pr->projectileID();
						//	auto ppu = BulletTeleport::CreatePlayerProjectileUpdate();
						//	((PlayerProjectileUpdate*)ppu)->projectileID = projID;
						//	((PlayerProjectileUpdate*)ppu)->curPosition = point;
						//	((PlayerProjectileUpdate*)ppu)->travelTime = pr->traveledTime() + Dist2Heli / lastVel.Length();
						//	LocalPlayer->SendProjectileUpdate(ppu);

						//	pr->traveledDistance(pr->traveledDistance() + Dist2Heli);
						//	pr->traveledTime(pr->traveledTime() + Dist2Heli / lastVel.Length());

						//	// HeadPoint = Vector3::MoveTowards(HeadPoint, curPosit, 0.2);
						//	HitTest* hitTest = pr->get_hit_test();
						//	hitTest->AttackRay(Ray(point, (heliPos - point).Normalized()));
						//	hitTest->HitTransform(heliTransform);
						//	hitTest->HitEntity(lastTarget);
						//	hitTest->HitPoint(InverseTransformPoint(heliTransform, heliPos));
						//	hitTest->HitNormal(InverseTransformDirection(heliTransform, heliPos));
						//	hitTest->DidHit(true);

						//	DoHit(pr, hitTest, heliPos, heliPos);
						//	return;
						//}

						/*Classes::DDrawSphere(Target.Cur->GetTransform(22)->Position(), 0.5f, Color(0, 1, 0, 1), 10, true);
						Classes::DDrawSphere(Target.Cur->GetTransform(19)->Position(), 0.5f, Color(1, 0, 0, 1), 10, true);*/
						// Classes::DDrawSphere(Target.Cur->GetTransform(56)->Position(), 0.5f, Color(0, 0, 1, 1), 10, true);
						// green tail
						// green tail
						Transform* transform = 0; //  = Target.Cur->get_transform();
						int health = (int)Target.Cur->GetHealth();
						if (health <= 5000) {
							transform = Target.Cur->GetTransform(19); // 22
						}
						else {
							transform = Target.Cur->GetTransform(22); // 19
						}

						Vector3 point = pr->currentPosition();
						Vector3 lastVel = pr->currentPosition();
						Vector3 tar = transform->Position();

						if (Unity::CheckLOS(tar, pr->currentPosition()) && Maths::Calc3D_Dist(pr->currentPosition(), tar) < 30) {

							HitTest* hitTest = pr->get_hit_test();
							hitTest->DidHit(true);
							hitTest->HitPart(2699525250);
							hitTest->HitEntity(Target.Cur);
							hitTest->HitTransform(transform);
							hitTest->HitPoint(InverseTransformPoint(transform, point));
							hitTest->HitNormal(InverseTransformDirection(transform, point));
							hitTest->AttackRay(Ray(point, tar - point));
							DoHit(pr, hitTest, HitPointWorld(hitTest), HitNormalWorld(hitTest));
							return;
	
						}
					}
				}
					
			}
		}
	}

	Update(pr);
}

float CalculateEffectScale_hk(Projectile* pr)
{
	/*if (Vars::Exploits::EffectScale && Vars::Exploits::effectScale >= 0 && Vars::Exploits::effectScale < 0xFFFFFFFF) {
		return Vars::Exploits::effectScale;
	}*/

	return 1.f;
}

//typedef void(__stdcall* TraceAll)(DWORD64, DWORD64, int);
//typedef DWORD64(__stdcall* Unknown)(DWORD64);
//typedef void(__stdcall* UnknownV)(DWORD64, DWORD64);
//typedef DWORD64(__stdcall* Unknown)(DWORD64);
//DWORD64 st = safe_read(g_Base + 49741600, DWORD64); //"Name": "Method$Facepunch.Pool.GetList\u003CTraceInfo\u003E()", address
//Unknown get_list = (Unknown)(g_Base + 17368544);//"Name": "Method$Facepunch.Pool.GetList\u003CTraceInfo\u003E()", MethodAddress
//
//DWORD64 rs = get_list(st);
//if (!rs) return false;
//
//int size = safe_read(rs + 0x18, int);
//DWORD64 lst = safe_read(rs + 0x10, DWORD64);
//
//Vector3 newPosition = Vector3::MoveTowards(point, Target.Pos, 0.99);
//float Distance = Maths::Calc3D_Dist(point, newPosition);
//
//auto ppu = CreatePlayerProjectileUpdate();
//((PlayerProjectileUpdate*)ppu)->projectileID = pr->projectileID();
//pr->previousPosition(newPosition);
//pr->currentPosition(newPosition);
//
//((PlayerProjectileUpdate*)ppu)->curPosition = newPosition;
//((PlayerProjectileUpdate*)ppu)->travelTime = pr->traveledTime() + Distance / pr->currentVelocity().Length();// pr->traveledTime() + dist / pr->currentVelocity().Length();
//LocalPlayer->SendProjectileUpdate(ppu);
//
//pr->traveledDistance(pr->traveledDistance() + Distance);
//pr->traveledTime(pr->traveledTime() + Distance / pr->currentVelocity().Length());
//
//hitTest->AttackRay(Ray(point, newPosition));
//hitTest->HitTransform(PlayerTrans);
//hitTest->HitEntity(Target.Cur);
//hitTest->HitPoint(InverseTransformPoint(PlayerTrans, newPosition));
//hitTest->HitNormal(Vector3(0, 0, 0));
//hitTest->DidHit(true);
//// hitTest->MaxDistance(999);
//
///*for (int i = 0; i < size && pr->IsAlive(); i++) {
//	TraceInfo Trace = safe_read(lst + 0x20 + (i * sizeof(TraceInfo)), TraceInfo);
//	if (Trace.valid) {
//		UpdateHitTest(Trace, pr);
//	}
//}*/
//
//DoHit(pr, hitTest, newPosition, Vector3(0, 0, 0));
//
////auto ppa = PoolGetPlayerProjectileAttack();
////((PlayerProjectileAttack*)ppu)->playerAttack->attack = BuildAttackMessage(hitTest, newPosition);// hitTest;
////((PlayerProjectileAttack*)ppu)->hitVelocity = pr->currentVelocity();
////((PlayerProjectileAttack*)ppu)->travelTime = pr->traveledTime() + Distance / pr->currentVelocity().Length();// pr->traveledTime() + dist / pr->currentVelocity().Length();
////LocalPlayer->SendProjectileAttack(ppu);
//
//return true;